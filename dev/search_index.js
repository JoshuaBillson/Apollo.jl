var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Apollo","category":"page"},{"location":"#Apollo","page":"Home","title":"Apollo","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Apollo.","category":"page"},{"location":"#Utility-Methods","page":"Home","title":"Utility Methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Apollo]\nPages = [\"src/utils.jl\", \"src/viz.jl\"]","category":"page"},{"location":"#Apollo.catlayers-Union{Tuple{D}, Tuple{Rasters.AbstractRasterStack, Type{D}}} where D<:DimensionalData.Dimensions.Dimension","page":"Home","title":"Apollo.catlayers","text":"catlayers(x::AbstractRasterStack, dim)\n\nConcatenate the layers of x along the dimension given by dim.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.dropobs-Union{Tuple{AbstractArray{<:Any, N}}, Tuple{N}} where N","page":"Home","title":"Apollo.dropobs","text":"dropobs(x::AbstractArray)\n\nRemove the observation dimension from the tensor x.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.folddims-Tuple{Any, Rasters.AbstractRaster}","page":"Home","title":"Apollo.folddims","text":"folddims(f, xs::AbstractRaster; dims=Band)\n\nApply the reducer function f to all non-missing elements in each slice of x WRT dims.\n\nArguments\n\nf: A function that reduces an array of values to a singular value.\nx: An AbstractRaster over which we want to fold.\ndims: The dimension used to generate each slice that is passed to f.\n\nExample\n\njulia> μ = folddims(mean, raster, dims=Band)\n6-element Vector{Float32}:\n 0.09044644\n 0.23737456\n 0.30892986\n 0.33931717\n 0.16186203\n 0.076255515\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.foldlayers-Tuple{Any, Rasters.AbstractRasterStack}","page":"Home","title":"Apollo.foldlayers","text":"foldlayers(f, x::AbstractRasterStack)\n\nApply the reducer f to all non-missing elements in each layer of x.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.ones_like-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Home","title":"Apollo.ones_like","text":"ones_like(x::AbstractArray)\n\nConstruct an array of ones with the same size and element type as x.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.putdim-Tuple{Rasters.AbstractRaster, Tuple}","page":"Home","title":"Apollo.putdim","text":"putdim(raster::AbstractRaster, dims)\n\nAdd the provided singleton dim(s) to raster. Does nothing if dims is already present.\n\nExample\n\njulia> r = Raster(rand(512,512), (X,Y));\n\njulia> putdim(r, Band)\n╭─────────────────────────────╮\n│ 512×512×1 Raster{Float64,3} │\n├─────────────────────────────┴─────────────────────────────── dims ┐\n  ↓ X   ,\n  → Y   ,\n  ↗ Band Sampled{Int64} Base.OneTo(1) ForwardOrdered Regular Points\n├─────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (1, 512), Y = (1, 512), Band = (1, 1))\n\n└───────────────────────────────────────────────────────────────────┘\n[:, :, 1]\n 0.107662  0.263251    0.786834  0.334663  …  0.316804   0.709557    0.478199\n 0.379863  0.532268    0.635206  0.33514      0.402433   0.413602    0.657538\n 0.129775  0.283808    0.327946  0.727027     0.685844   0.847777    0.435326\n 0.73348   0.00705636  0.178885  0.381932     0.146575   0.310242    0.159852\n ⋮                                         ⋱                         ⋮\n 0.330857  0.52704     0.888379  0.811084  …  0.0660687  0.00230472  0.448761\n 0.698654  0.510846    0.916446  0.621061     0.23648    0.510697    0.113338\n 0.600629  0.116626    0.567983  0.174267     0.089853   0.443758    0.667935\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.putobs-Tuple{AbstractArray}","page":"Home","title":"Apollo.putobs","text":"putobs(x::AbstractArray)\n\nAdd an N+1 obervation dimension of size 1 to the tensor x.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.stackobs-Tuple","page":"Home","title":"Apollo.stackobs","text":"stackobs(x...)\nstackobs(x::AbstractVector)\n\nStack the elements in x as if they were observations in a batch. If x is an AbstractArray,  elements will be concatenated along the Nth dimension. Other data types will simply be placed in a Vector in the same order as they were received. Special attention is paid to a Vector of Tuples, where each tuple represents a single observation, such as a feature/label pair. In this case, the tuples will first be unzipped, before their constituent elements are then stacked as usual.\n\nExample\n\njulia> stackobs(1, 2, 3, 4, 5)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\njulia> stackobs([(1, :a), (2, :b), (3, :c)])\n([1, 2, 3], [:a, :b, :c])\n\njulia> stackobs([rand(256, 256, 3, 1) for _ in 1:10]...) |> size\n(256, 256, 3, 10)\n\njulia> xs = [rand(256, 256, 3, 1) for _ in 1:10];\n\njulia> ys = [rand(256, 256, 1, 1) for _ in 1:10];\n\njulia> data = collect(zip(xs, ys));\n\njulia> stackobs(data) .|> size\n((256, 256, 3, 10), (256, 256, 1, 10))\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.todevice-Tuple{Any}","page":"Home","title":"Apollo.todevice","text":"todevice(x)\n\nCopy x to the GPU.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.unzip-Tuple{AbstractVector}","page":"Home","title":"Apollo.unzip","text":"unzip(x::AbstractVector{<:Tuple})\n\nThe reverse of zip.\n\nExample\n\njulia> zip([1, 2, 3], [:a, :b, :c]) |> collect |> unzip\n([1, 2, 3], [:a, :b, :c])\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.vec2array-Union{Tuple{N}, Tuple{T}, Tuple{AbstractVector, AbstractArray{T, N}, Int64}} where {T, N}","page":"Home","title":"Apollo.vec2array","text":"vec2array(x::AbstractVector, to::AbstractArray, dim::Int)\n\nReshape the vector x to have the same number of dimensions as to. Missing dimensions  are added as singletons while the dimension corresponding to dim will be filled with the values of x.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.zeros_like-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Home","title":"Apollo.zeros_like","text":"zeros_like(x::AbstractArray)\n\nConstruct an array of zeros with the same size and element type as x.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.mosaicview-Tuple{Tuple{Int64, Int64}, Vararg{Any}}","page":"Home","title":"Apollo.mosaicview","text":"mosaicview(size::Tuple{Int,Int}, imgs...)\n\nPlot a mosaic of images with size (rows, cols).\n\n\n\n\n\n","category":"method"},{"location":"#Data","page":"Home","title":"Data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Apollo]\nPages = [\n    \"src/data/common.jl\", \n    \"src/data/views.jl\", \n    \"src/data/samplers.jl\", \n    \"src/data/methods.jl\", \n    \"src/data/transforms.jl\"\n]","category":"page"},{"location":"#Apollo.DType","page":"Home","title":"Apollo.DType","text":"The super-type of all data types.\n\n\n\n\n\n","category":"type"},{"location":"#Apollo.Image","page":"Home","title":"Apollo.Image","text":"Image([name])\n\nRepresents a type consisting of image data.\n\n\n\n\n\n","category":"type"},{"location":"#Apollo.Mask","page":"Home","title":"Apollo.Mask","text":"Mask([name])\n\nRepresents an instance of mask data.\n\n\n\n\n\n","category":"type"},{"location":"#Apollo.ObsView","page":"Home","title":"Apollo.ObsView","text":"ObsView(data, indices)\n\nConstruct an iterator over data\n\n\n\n\n\n","category":"type"},{"location":"#Apollo.dropobs-Tuple{Any, AbstractVector{Int64}}","page":"Home","title":"Apollo.dropobs","text":"dropobs(data, obs::AbstractVector{Int})\n\nRemove all observations from data whose index corresponds to those in obs.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.filterobs-Tuple{Any, Any}","page":"Home","title":"Apollo.filterobs","text":"filterobs(f, data)\n\nRemove all observations from data for which f returns false.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.mapobs-Tuple{Any, Any}","page":"Home","title":"Apollo.mapobs","text":"mapobs(f, data)\n\nLazily apply the function f to each element in data.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.repeatobs-Tuple{Any, Int64}","page":"Home","title":"Apollo.repeatobs","text":"repeatobs(data, n::Int)\n\nCreate a new view which iterates over every element in data n times.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.sampleobs-Tuple{Any, Any, Int64}","page":"Home","title":"Apollo.sampleobs","text":"sampleobs([rng], data, n)\n\nRandomly sample n elements from data without replacement. rng may be optionally provided for reproducible results.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.shuffleobs-Tuple{Any, Any}","page":"Home","title":"Apollo.shuffleobs","text":"shuffleobs([rng], data)\n\nRandomly shuffle the elements of data. Provide rng for reproducible results.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.splitobs-Tuple{Any}","page":"Home","title":"Apollo.splitobs","text":"splitobs(data; at=0.8, shuffle=true)\n\nReturn a set of indices that splits the given observations according to the given break points.\n\nArguments\n\ndata: Any type that implements Base.length(). \nat: The fractions at which to split data. \nshuffle: If true, shuffles the indices before splitting. \n\nExample\n\njulia> splitobs(1:100, at=(0.7, 0.2), shuffle=false)\n3-element Vector{Vector{Int64}}:\n [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  61, 62, 63, 64, 65, 66, 67, 68, 69, 70]\n [71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90]\n [91, 92, 93, 94, 95, 96, 97, 98, 99, 100]\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.takeobs-Tuple{Any, AbstractVector{Int64}}","page":"Home","title":"Apollo.takeobs","text":"takeobs(data, obs::AbstractVector{Int})\n\nTake all observations from data whose index corresponds to obs while removing everything else.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.zipobs-Tuple","page":"Home","title":"Apollo.zipobs","text":"zipobs(data...)\n\nCreate a new iterator where the elements of each iterator in data are returned as a tuple.\n\nExample\n\njulia> zipobs(1:5, 41:45, rand([:cat, :dog], 5)) |> collect\n5-element Vector{Any}:\n (1, 41, :dog)\n (2, 42, :cat)\n (3, 43, :cat)\n (4, 44, :dog)\n (5, 45, :cat)\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.TileSampler","page":"Home","title":"Apollo.TileSampler","text":"TileSampler(raster, tilesize::Int; stride=tilesize)\n\nAn object that iterates over tiles cut from a given raster.\n\nParameters\n\nraster: An AbstractRaster or AbstractRasterStack to be cut into tiles.\ntilesize: The size (width and height) of the tiles.\nstride: The horizontal and vertical distance between adjacent tiles.\n\n\n\n\n\n","category":"type"},{"location":"#Apollo.crop","page":"Home","title":"Apollo.crop","text":"crop(x::AbstractArray, size, ul=(1,1))\n\nCrop a tile equal to size out of x with an upper-left corner defined by ul.\n\n\n\n\n\n","category":"function"},{"location":"#Apollo.raster-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Tuple}} where {T, N}","page":"Home","title":"Apollo.raster","text":"raster(tensor::AbstractArray, dims::Tuple; missingval=0)\n\nRestore the raster dimensions given by dims to the provided tensor. The final dimension of tensor, which is assumed to be the observation dimension, will be dropped.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.tensor-Tuple","page":"Home","title":"Apollo.tensor","text":"tensor([precision], xs...; kwargs...)\ntensor([precision], x::AbstractArray; kwargs...)\ntensor([precision], x::AbstractRasterStack; layerdim=Band)\n\nConvert one or more arrays to a tensor with an element type of precision. AbstractRasters will be reshaped as necessary to enforce a dimension order of (X,Y,Z,Band,Ti) before adding an observation dimension. Multiple arrays will be  concatenated along the observation dimension after being converted to tensors.\n\nParameters\n\nprecision: Any AbstractFloat to use as the tensor's type (default = Float32).\nx: One or more AbstractArrays to be turned into tensors.\nlayerdim: AbstractRasterStacks will have their layers concatenated along this dimension\n\nbefore being turned into tensors.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.transform-Tuple{AbstractTransform, Any, Any}","page":"Home","title":"Apollo.transform","text":"transform(t::AbstractTransform, dtype::DType, x)\ntransform(t::AbstractTransform, dtypes::Tuple, x::Tuple)\n\nApply the transformation t to the input x with data type dtype.\n\n\n\n\n\n","category":"method"},{"location":"#Metrics","page":"Home","title":"Metrics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Apollo]\nPages = [\n    \"src/metrics/common.jl\", \n    \"src/metrics/tracker.jl\", \n    \"src/metrics/classification.jl\", \n    \"src/metrics/regression.jl\", \n]","category":"page"},{"location":"#Apollo.AbstractMetric","page":"Home","title":"Apollo.AbstractMetric","text":"Abstract supertype of all evaluation metrics.\n\n\n\n\n\n","category":"type"},{"location":"#Apollo.Metric","page":"Home","title":"Apollo.Metric","text":"Metric(measure::AbstractMetric)\n\nConstruct a Metric object to track the state for the given AbstractMetric.\n\n\n\n\n\n","category":"type"},{"location":"#Apollo.compute","page":"Home","title":"Apollo.compute","text":"compute(m::AbstractMetric, state)\ncompute(m::Metric)\n\nCompute the performance measure from the current state.\n\n\n\n\n\n","category":"function"},{"location":"#Apollo.evaluate-Tuple{Any, Any, Vararg{AbstractMetric}}","page":"Home","title":"Apollo.evaluate","text":"evaluate(model, data, measures...)\n\nEvaluate the model's performance on the provided data.\n\nParameters\n\nmodel: A callable that takes a single batch from data and returns a tuple of the form (ŷ, y).\ndata: An iterable of (x, y) values.\nmeasures: A set of AbstractMetrics to use for evaluating model.\n\nReturns\n\nA NamedTuple containing the performance metrics for the given model.\n\nExample\n\nevaluate(DataLoader((xsampler, ysampler)), Accuracy(), MIoU(2)) do (x, y)\n    ŷ = model(x) |> Flux.sigmoid\n    return (ŷ, y)\nend\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.init","page":"Home","title":"Apollo.init","text":"init(m::AbstractMetric)\n\nReturns the initial state of the performance measure, which will be subsequently updated for each mini-batch of labels and predictions.\n\n\n\n\n\n","category":"function"},{"location":"#Apollo.name-Tuple{M} where M<:AbstractMetric","page":"Home","title":"Apollo.name","text":"name(m::AbstractMetric)\nname(m::Metric)\n\nHuman readable name of the given performance measure.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.reset!-Tuple{Apollo.Metric}","page":"Home","title":"Apollo.reset!","text":"reset!(metric::Metric)\n\nReset the metric's state.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.update","page":"Home","title":"Apollo.update","text":"update(m::AbstractMetric, state, ŷ, y)\n\nReturn the new state for the given batch of labels and predictions.\n\n\n\n\n\n","category":"function"},{"location":"#Apollo.update!-Tuple{Apollo.Metric, Any, Any}","page":"Home","title":"Apollo.update!","text":"update!(metric::Metric, ŷ, y)\nupdate!(tracker::Tracker, ŷ, y)\n\nUpdate the metric state for the next batch of labels and predictions.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.epoch!-Tuple{Tracker}","page":"Home","title":"Apollo.epoch!","text":"epoch!(tracker::Tracker)\n\nStore the metric value for the current epoch and reset the state.\n\n\n\n\n\n","category":"method"},{"location":"#Apollo.step!-Tuple{Tracker, String, Any, Any}","page":"Home","title":"Apollo.step!","text":"step!(tracker::Tracker, ŷ, y)\n\nUpdate the metric's state for the current batch of predictions and labels.\n\n\n\n\n\n","category":"method"},{"location":"#Models","page":"Home","title":"Models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Apollo]\nPages = [\n    \"src/models/layers.jl\", \n    \"src/models/encoders.jl\", \n    \"src/models/classifiers.jl\", \n    \"src/models/deeplab.jl\", \n    \"src/models/unet.jl\", \n    \"src/models/r2unet.jl\", \n    \"src/models/ssc_cnn.jl\", \n]","category":"page"},{"location":"#Apollo.UNet-Tuple{}","page":"Home","title":"Apollo.UNet","text":"UNet(;encoder=StandardEncoder(batch_norm=true), input=nothing, channels=3, nclasses=1, batch_norm=true)\n\nConstruct a UNet model.\n\nKeywords\n\nencoder: The encoder to use for the UNet model. Defaults to the standard encoder.\ninput: The input block, which defaults to two convolutional layers as with standard UNet.\nchannels: The number of input channels to use when input=nothing. Ignored when input is specified.\nnclasses: The number of output channels produced by the head.\nbatch_norm: Use batch normalization after each convolutional layer (default=true).\n\n\n\n\n\n","category":"method"}]
}
